#https://leetcode.com/problems/remove-invalid-parentheses/
'''
Given a string, remove the minimal number of parentheses required to make the string valid again.

    Inp: "()())()"
    Out: ["()()()", "(())()"]

    Inp: "(a)())()"
    Out: ["(a)()()", "(a())()"]

    Inp: ")("
    Out: [""]
'''
class Solution(object):
    '''
    Checking if a string is valid is straightforward. 
    Now, we start with the base string s.
    
    At each level, we generate all valid strings possible by deleting a single character from s. 
    Then we filter this list to see if we get any valid strings out of this. 
    
    If not, we repeat this process until we are done.
    '''
    def _isValid(self, s):
        # A string is valid if it always has left parentheses count >= right count. And if there are equal number of both parentheses at the end of the string.
        if not s:
            return True
        ctr = 0
        for char in s:
            if char == '(':
                ctr +=1
            elif char == ')':
                ctr -= 1
                if ctr < 0:
                    return False
        return ctr == 0

    def removeInvalidParentheses(self, s):
        if not s:   return ['']
        # The strings we have at the current level (level 0) is just the input string s
        currLevelStrings = {s}

        while True:
            # We filter all of currLevelStrings checking for valid strings
            validStrings = filter(self._isValid, currLevelStrings)
            # If we even find ONE valid string, then this is the list of valid strings with minimum number of removals
            if validStrings:
                return list(validStrings)
            # Since we haven't had any valid strings at this level, we generate the next level of strings
            # The next level of strings is generated by remove one letter at a time from each of the previous level's strings
            currLevelStrings = {s[:i]+s[i+1:] for s in currLevelStrings for i in xrange(len(s))}

# ----------------------------------------------------------------------------------------------------------------

    def _remove(self, s, res, last_i, last_j, par):
        '''
        Removes all invalid parentheses as per required and appends the valid ones to the result.
        Inp:
            s:      str, input string
            res:    list, list containing the result strings
            last_i: int, the last location at which the string became invalid
            last_j: int, the last location at which we removed a parenthesis
            par:    str, string of length 2 which represents the order of parentheses that we are looking at. () means we are looking to remove extra ). () means we are looking to remove any extra (
        '''
        ctr = 0
        for i in xrange(last_i, len(s)):
            # Altering counter based on which parentheses we see
            ctr += (s[i]==par[0]) - (s[i]==par[1])

            # If counter is >=0, we are still having a valid string
            if ctr >= 0:
                continue

            # If the code has reached this point, then ctr < 0 => We have more par[1] than par[0] at this point.
            # We start looking ahead from the last location that we removed a parentheses and try to find another offending par[1].
            # This par[1] should be such that it's either at the same location that we removed one the previous time (OR) it should not be the 2nd or 3rd or so of a series of parentheses (s[j-1]!=par[1])
            for j in xrange(last_j, i+1):
                if s[j] == par[1] and (j==last_j or s[j-1]!=par[1]):    # We allow j==last_j because the current string was obtained by removing last_j from the previous string. So last_string[j+1] is currStr[j] which is still an unremoved/NOT previously deleted paren
                    self._remove(s[:j]+s[j+1:], res, i, j, par)
            return

        # If the code has reached this point, then i has reached len(s)
        rev = s[::-1]
        # If par[0] is ), then we have performed both L-R and R-L checks, thus eliminating both extra ) and extra (. Thus we can now append the reverse(s) (s itself is now reverse(the original input s))
        if par[0] == ')':
            res.append(rev)
        # If par[0]!+')', then we have only completed the first L-R check. We now trigger the R-L check.
        else:
            self._remove(rev, res, 0, 0, ')(')

    def removeInvalidParenthesesPruned(self, s):
        #https://discuss.leetcode.com/topic/34875/easy-short-concise-and-fast-java-dfs-3-ms-solution/14
        ''' 
        In this beautiful solution, we try to adhere to a few principles. 
        First, we attempt to run through the array and remove any errant right parentheses to make it valid.
        At the end of this first stage, we will have removed all the necessary ) to try and make it valid. 
        Since removal of ) does not just make the string a valid string, we next attempt to try and remove any extra ( that may exist.


        The way we accomplish the second stage, is by reversing the string and reversing the order of parentheses we consider
        '''
        if not s:   return ['']
        res = []
        self._remove(s, res, 0, 0, '()')
        return res

s = Solution()
print s.removeInvalidParenthesesPruned('()())()')
print s.removeInvalidParenthesesPruned('(a)())()')
print s.removeInvalidParenthesesPruned(')(')
